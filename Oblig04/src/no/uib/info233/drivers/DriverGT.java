package no.uib.info233.drivers;import java.util.Iterator;import no.uib.info233.tree.LinkedGeneralTree;import no.uib.info233.tree.GeneralTree;/** * A driver that demonstrates the class GeneralTree. *  * @author Frank M. Carrano * @author Timothy M. Henry * @version 4.2 */public class DriverGT {    public static void main(String[] args) {        // Figure 23-1        System.out.println("\nThe tree in Figure 23-1:\n");        System.out.println("         Carole");        System.out.println("        /   |  \\"); // '\\' is the escape character for backslash        System.out.println("       /    |   \\");        System.out.println("      /     |    \\");        System.out.println("   Brett Jennifer Brian");        System.out.println("    /     / \\");        System.out.println("   /     /   \\");        System.out.println("  /     /     \\");        System.out.println("Susan Jared  Jamie ");        System.out.println();        // Leaves        GeneralTree<String> brianTree = new LinkedGeneralTree<>("Brian");        GeneralTree<String> susanTree = new LinkedGeneralTree<>("Susan");        GeneralTree<String> jaredTree = new LinkedGeneralTree<>("Jared");        GeneralTree<String> jamieTree = new LinkedGeneralTree<>("Jamie");        // Subtrees:        // The casts are safe because the new arrays contains null entries        @SuppressWarnings("unchecked")        GeneralTree<String>[] brettChildren = new LinkedGeneralTree[2];        brettChildren[0] = susanTree;        brettChildren[1] = null;        GeneralTree<String> brettTree = new LinkedGeneralTree<>();        brettTree.setTree("Brett", brettChildren);        @SuppressWarnings("unchecked")        GeneralTree<String>[] jenniferChildren = new LinkedGeneralTree[2];        jenniferChildren[0] = jaredTree;        jenniferChildren[1] = jamieTree;        GeneralTree<String> jenniferTree = new LinkedGeneralTree<>();        jenniferTree.setTree("Jennifer", jenniferChildren);        @SuppressWarnings("unchecked")        GeneralTree<String>[] caroleChildren = new LinkedGeneralTree[3];        caroleChildren[0] = brettTree;        caroleChildren[1] = jenniferTree;        caroleChildren[2] = brianTree;        GeneralTree<String> caroleTree = new LinkedGeneralTree<>();        caroleTree.setTree("Carole", caroleChildren);        showTreeStats(caroleTree, "carole", 7);        testTraversals(caroleTree, "carole brett susan jennifer jared jamie brian",                "susan brett jared jamie jennifer brian carole");        testEmptyTree();        System.out.println("Done.");    }    /** Tests the 4 traversals of a given binary tree. */    public static void testTraversals(GeneralTree<String> aTree, String preorder, String postorder) {        testPreorder(aTree, preorder);        testPostorder(aTree, postorder);    }    public static void showTreeStats(GeneralTree<String> tree, String root, int numberOfNodes) {        if (tree.isEmpty()) {            System.out.println("The tree is empty");        } else {            System.out.println("The tree is not empty");        }        System.out.println("Root of tree is " + tree.getRootData() + "; s/b " + root);        System.out.println("# nodes in tree is " + tree.getNumberOfNodes() + "; s/b " + numberOfNodes);    }    public static void testPreorder(GeneralTree<String> tree, String answer) {        System.out.println("\nPreorder:");        System.out.println(answer + "  Expected");        Iterator<String> preorder = tree.preorderIterator();        while (preorder.hasNext()) {            System.out.print(preorder.next() + " ");        }        System.out.println(" Actual using PreorderIterator");        System.out.println("---------------");    }    public static void testPostorder(GeneralTree<String> tree, String answer) {        System.out.println("\nPostOrder:");        System.out.println(answer + "  Expected");        Iterator<String> postorder = tree.postorderIterator();        while (postorder.hasNext()) {            System.out.print(postorder.next() + " ");        }        System.out.println(" Actual using PostorderIterator\n---------------");    }    public static void testEmptyTree() {        System.out.println("\nTest empty tree:");        GeneralTree<String> myTree = new LinkedGeneralTree<>();        // myTree.root is null, so myTree is empty, not null        if (myTree == null) {            System.out.println("myTree is null--ERROR");        } else {            System.out.println("myTree is not null--CORRECT.");            if (myTree.isEmpty()) {                System.out.println("myTree is empty--CORRECT.");            } else {                System.out.println("myTree.root is not empty--ERROR");            }        }        System.out.println();    }}/* *  * The tree in Figure 23-1: *  * Carole / | \ / | \ / | \ Brett Jennifer Brian / / \ / / \ / / \ Susan Jared * Jamie *  * The tree is not empty Root of tree is Carole; s/b carole # nodes in tree is * 7; s/b 7 *  * Preorder: carole brett susan jennifer jared jamie brian Expected Carole Brett * Susan Jennifer Jared Jamie Brian Actual using PreorderIterator * --------------- *  * PostOrder: susan brett jared jamie jennifer brian carole Expected Susan Brett * Jared Jamie Jennifer Brian Carole Actual using PostorderIterator * --------------- *  * Test empty tree: myTree is not null--CORRECT. myTree is empty--CORRECT. *  * Done. *  */