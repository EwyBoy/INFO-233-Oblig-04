package no.uib.info233.drivers;import java.util.Iterator;import no.uib.info233.tree.LinkedCloneableBinaryTree;/** * A driver that demonstrates the class CloneableBinaryTree. *  * @author Frank M. Carrano * @author Timothy M. Henry * @version 4.2 */public class DriverCBT {    public static void main(String[] args) {        LinkedCloneableBinaryTree<String> aTree = new LinkedCloneableBinaryTree<>();        createTree(aTree);        showTreeStats(aTree, "A", 4, 8);        testLevelOrder(aTree, "A B C D E F G H");        testPreorder(aTree, "A B D H E C F G");        testInorder(aTree, "D H B E A F C G");        testPostorder(aTree, "H D E B F G C A");        System.out.println("===================");        System.out.println("======CLONE========");        @SuppressWarnings("unchecked")        LinkedCloneableBinaryTree<String> copyTree = (LinkedCloneableBinaryTree<String>) aTree.clone();        showTreeStats(copyTree, "A", 4, 8);        testLevelOrder(copyTree, "A B C D E F G H");        testPreorder(copyTree, "A B D H E C F G");        testInorder(copyTree, "D H B E A F C G");        testPostorder(copyTree, "H D E B F G C A");        System.out.println("======CHANGE THE ROOT OF THE ORIGINAL TREE========");        aTree.setRootData("Z");        showTreeStats(aTree, "Z", 4, 8);        testLevelOrder(aTree, "Z B C D E F G H");        testPreorder(aTree, "Z B D H E C F G");        testInorder(aTree, "D H B E Z F C G");        testPostorder(aTree, "H D E B F G C Z");        System.out.println("======CLONE========");        showTreeStats(copyTree, "A", 4, 8);        testLevelOrder(copyTree, "A B C D E F G H");        testPreorder(copyTree, "A B D H E C F G");        testInorder(copyTree, "D H B E A F C G");        testPostorder(copyTree, "H D E B F G C A");        System.out.println("======CHANGE THE ROOT OF THE CLONE========");        copyTree.setRootData("Y");        showTreeStats(copyTree, "Y", 4, 8);        testLevelOrder(copyTree, "Y B C D E F G H");        testPreorder(copyTree, "Y B D H E C F G");        testInorder(copyTree, "D H B E Y F C G");        testPostorder(copyTree, "H D E B F G C Y");        System.out.println("======ORIGINAL TREE========");        showTreeStats(aTree, "Z", 4, 8);        testLevelOrder(aTree, "Z B C D E F G H");        testPreorder(aTree, "Z B D H E C F G");        testInorder(aTree, "D H B E Z F C G");        testPostorder(aTree, "H D E B F G C Z");        System.out.println("Done.");    }    public static void createTree(LinkedCloneableBinaryTree<String> tree) { // D has H as right child        // Leaves        LinkedCloneableBinaryTree<String> eTree = new LinkedCloneableBinaryTree<>("E");        LinkedCloneableBinaryTree<String> fTree = new LinkedCloneableBinaryTree<>("F");        LinkedCloneableBinaryTree<String> gTree = new LinkedCloneableBinaryTree<>("G");        LinkedCloneableBinaryTree<String> hTree = new LinkedCloneableBinaryTree<>("H");        // Subtrees:        LinkedCloneableBinaryTree<String> dTree = new LinkedCloneableBinaryTree<>("D", null, hTree);        LinkedCloneableBinaryTree<String> bTree = new LinkedCloneableBinaryTree<>("B", dTree, eTree);        LinkedCloneableBinaryTree<String> cTree = new LinkedCloneableBinaryTree<>("C", fTree, gTree);        tree.setTree("A", bTree, cTree);        System.out.println("\nA tree:\n");        System.out.println("     A      ");        System.out.println("   /   \\   ");        System.out.println("  B     C   ");        System.out.println(" / \\   / \\");        System.out.println("D   E  F  G ");        System.out.println(" \\         ");        System.out.println("  H         ");        System.out.println();    }    public static void showTreeStats(LinkedCloneableBinaryTree<String> tree, String root, int height, int numberOfNodes) {        if (tree.isEmpty()) {            System.out.println("The tree is empty");        } else {            System.out.println("The tree is not empty");        }        System.out.println("Root of tree is " + tree.getRootData() + "; s/b " + root);        System.out.println("Height of tree is " + tree.getHeight() + "; s/b " + height);        System.out.println("# nodes in tree is " + tree.getNumberOfNodes() + "; s/b " + numberOfNodes);    }    public static void testLevelOrder(LinkedCloneableBinaryTree<String> tree, String answer) {        System.out.println("\nLevel order:");        System.out.println(answer + "  Expected");        Iterator<String> levelOrder = tree.levelorderIterator();        while (levelOrder.hasNext()) {            System.out.print(levelOrder.next() + " ");        }        System.out.println(" Actual\n---------------");    }    public static void testPreorder(LinkedCloneableBinaryTree<String> tree, String answer) {        System.out.println("\nPreorder:");        System.out.println(answer + "  Expected");        Iterator<String> preorder = tree.preorderIterator();        while (preorder.hasNext()) {            System.out.print(preorder.next() + " ");        }        System.out.println(" Actual\n---------------");    }    public static void testInorder(LinkedCloneableBinaryTree<String> tree, String answer) {        System.out.println("\nInorder:");        System.out.println(answer + "  Expected");        Iterator<String> inorder = tree.inorderIterator();        while (inorder.hasNext()) {            System.out.print(inorder.next() + " ");        }        System.out.println(" Actual\n---------------");    }    public static void testPostorder(LinkedCloneableBinaryTree<String> tree, String answer) {        System.out.println("\nPostOrder:");        System.out.println(answer + "  Expected");        Iterator<String> postorder = tree.postorderIterator();        while (postorder.hasNext()) {            System.out.print(postorder.next() + " ");        }        System.out.println(" Actual\n---------------");    }}/* *  * A tree: *  * A / \ B C / \ / \ D E F G \ H *  * The tree is not empty Root of tree is A; s/b A Height of tree is 4; s/b 4 # * nodes in tree is 8; s/b 8 *  * Level order: A B C D E F G H Expected A B C D E F G H Actual --------------- *  * Preorder: A B D H E C F G Expected A B D H E C F G Actual --------------- *  * Inorder: D H B E A F C G Expected D H B E A F C G Actual --------------- *  * PostOrder: H D E B F G C A Expected H D E B F G C A Actual --------------- * =================== ======CLONE======== The tree is not empty Root of tree is * A; s/b A Height of tree is 4; s/b 4 # nodes in tree is 8; s/b 8 *  * Level order: A B C D E F G H Expected A B C D E F G H Actual --------------- *  * Preorder: A B D H E C F G Expected A B D H E C F G Actual --------------- *  * Inorder: D H B E A F C G Expected D H B E A F C G Actual --------------- *  * PostOrder: H D E B F G C A Expected H D E B F G C A Actual --------------- * ======CHANGE THE ROOT OF THE ORIGINAL TREE======== The tree is not empty Root * of tree is Z; s/b Z Height of tree is 4; s/b 4 # nodes in tree is 8; s/b 8 *  * Level order: Z B C D E F G H Expected Z B C D E F G H Actual --------------- *  * Preorder: Z B D H E C F G Expected Z B D H E C F G Actual --------------- *  * Inorder: D H B E Z F C G Expected D H B E Z F C G Actual --------------- *  * PostOrder: H D E B F G C Z Expected H D E B F G C Z Actual --------------- * ======CLONE======== The tree is not empty Root of tree is A; s/b A Height of * tree is 4; s/b 4 # nodes in tree is 8; s/b 8 *  * Level order: A B C D E F G H Expected A B C D E F G H Actual --------------- *  * Preorder: A B D H E C F G Expected A B D H E C F G Actual --------------- *  * Inorder: D H B E A F C G Expected D H B E A F C G Actual --------------- *  * PostOrder: H D E B F G C A Expected H D E B F G C A Actual --------------- * ======CHANGE THE ROOT OF THE CLONE======== The tree is not empty Root of tree * is Y; s/b Y Height of tree is 4; s/b 4 # nodes in tree is 8; s/b 8 *  * Level order: Y B C D E F G H Expected Y B C D E F G H Actual --------------- *  * Preorder: Y B D H E C F G Expected Y B D H E C F G Actual --------------- *  * Inorder: D H B E Y F C G Expected D H B E Y F C G Actual --------------- *  * PostOrder: H D E B F G C Y Expected H D E B F G C Y Actual --------------- * ======ORIGINAL TREE======== The tree is not empty Root of tree is Z; s/b Z * Height of tree is 4; s/b 4 # nodes in tree is 8; s/b 8 *  * Level order: Z B C D E F G H Expected Z B C D E F G H Actual --------------- *  * Preorder: Z B D H E C F G Expected Z B D H E C F G Actual --------------- *  * Inorder: D H B E Z F C G Expected D H B E Z F C G Actual --------------- *  * PostOrder: H D E B F G C Z Expected H D E B F G C Z Actual --------------- * Done. *  */