package no.uib.info233.tree;/** * A class that implements the ADT binary search tree by extending BinaryTree. * Recursive version. *  * @author Frank M. Carrano * @author Timothy M. Henry * @version 4.2 */public class LinkedBinarySearchTree<T extends Comparable<? super T>> extends LinkedBinaryTree<T> implements SearchTree<T> {    public LinkedBinarySearchTree() {        super();    }    public LinkedBinarySearchTree(T rootEntry) {        super();        setRootNode(new BinaryTreeNode<>(rootEntry));    }    public void setTree(T rootData) // Disable setTree (see Segment 25.6)    {        throw new UnsupportedOperationException();    }    public void setTree(T rootData, BinaryTree<T> leftTree, BinaryTree<T> rightTree) {        throw new UnsupportedOperationException();    }    @Override    public T getEntry(T entry) {        return findEntry(getRootNode(), entry);    }    // Recursively finds the given entry in the binary tree rooted at the given    // node.    private T findEntry(BinaryTreeNode<T> rootNode, T entry) {        T result = null;        if (rootNode != null) {            T rootEntry = rootNode.getData();            if (entry.equals(rootEntry)) {                result = rootEntry;            } else if (entry.compareTo(rootEntry) < 0) {                result = findEntry(rootNode.getLeftChild(), entry);            } else {                result = findEntry(rootNode.getRightChild(), entry);            }        }        return result;    }    @Override    public Boolean contains(T entry) {        return getEntry(entry) != null;    }    @Override    public T add(T newEntry) {        T result = null;        if (isEmpty()) {            setRootNode(new BinaryTreeNode<>(newEntry));        } else {            result = addEntry(getRootNode(), newEntry);        }        return result;    }    // Adds newEntry to the nonempty subtree rooted at rootNode.    private T addEntry(BinaryTreeNode<T> rootNode, T newEntry) {        assert rootNode != null;        T result = null;        int comparison = newEntry.compareTo(rootNode.getData());        if (comparison == 0) {            result = rootNode.getData();            rootNode.setData(newEntry);        } else if (comparison < 0) {            if (rootNode.hasLeftChild()) {                result = addEntry(rootNode.getLeftChild(), newEntry);            } else {                rootNode.setLeftChild(new BinaryTreeNode<>(newEntry));            }        } else {            assert comparison > 0;            if (rootNode.hasRightChild()) {                result = addEntry(rootNode.getRightChild(), newEntry);            } else {                rootNode.setRightChild(new BinaryTreeNode<>(newEntry));            }        }        return result;    }    @Override    public T remove(T entry) {        ReturnObject oldEntry = new ReturnObject(null);        BinaryTreeNode<T> newRoot = removeEntry(getRootNode(), entry, oldEntry);        setRootNode(newRoot);        return oldEntry.get();    }    // Removes an entry from the tree rooted at a given node.    // Parameters:    // rootNode A reference to the root of a tree.    // entry The object to be removed.    // oldEntry An object whose data field is null.    // Returns: The root node of the resulting tree; if entry matches    // an entry in the tree, oldEntry's data field is the entry    // that was removed from the tree; otherwise it is null.    private BinaryTreeNode<T> removeEntry(BinaryTreeNode<T> rootNode, T entry, ReturnObject oldEntry) {        if (rootNode != null) {            T rootData = rootNode.getData();            int comparison = entry.compareTo(rootData);            if (comparison == 0) // entry == root entry            {                oldEntry.set(rootData);                rootNode = removeFromRoot(rootNode);            } else if (comparison < 0) // entry < root entry            {                BinaryTreeNode<T> leftChild = rootNode.getLeftChild();                BinaryTreeNode<T> subtreeRoot = removeEntry(leftChild, entry, oldEntry);                rootNode.setLeftChild(subtreeRoot);            } else // entry > root entry            {                BinaryTreeNode<T> rightChild = rootNode.getRightChild();                rootNode.setRightChild(removeEntry(rightChild, entry, oldEntry));            }        }        return rootNode;    }    // Removes the entry in a given root node of a subtree.    // Parameter:    // rootNode A reference to the root of the subtree.    // Returns: The root node of the revised subtree.    private BinaryTreeNode<T> removeFromRoot(BinaryTreeNode<T> rootNode) {        // Case 1: rootNode has two children        if (rootNode.hasLeftChild() && rootNode.hasRightChild()) {            // Find node with largest entry in left subtree            BinaryTreeNode<T> leftSubtreeRoot = rootNode.getLeftChild();            BinaryTreeNode<T> largestNode = findLargest(leftSubtreeRoot);            // Replace entry in root            rootNode.setData(largestNode.getData());            // Remove node with largest entry in left subtree            rootNode.setLeftChild(removeLargest(leftSubtreeRoot));        }        // Case 2: rootNode has at most one child        else if (rootNode.hasRightChild()) {            rootNode = rootNode.getRightChild();        } else {            rootNode = rootNode.getLeftChild();            // Assertion: If rootNode was a leaf, it is now null        }        return rootNode;    }    // Finds the node containing the largest entry in a given tree.    // Parameter:    // rootNode A reference to the root node of the tree.    // Returns: The node containing the largest entry in the tree.    private BinaryTreeNode<T> findLargest(BinaryTreeNode<T> rootNode) {        if (rootNode.hasRightChild()) {            rootNode = findLargest(rootNode.getRightChild());        }        return rootNode;    }    // Removes the node containing the largest entry in a given tree.    // Parameter:    // rootNode A reference to the root node of the tree.    // Returns: The root node of the revised tree.    private BinaryTreeNode<T> removeLargest(BinaryTreeNode<T> rootNode) {        if (rootNode.hasRightChild()) {            BinaryTreeNode<T> rightChild = rootNode.getRightChild();            rightChild = removeLargest(rightChild);            rootNode.setRightChild(rightChild);        } else {            rootNode = rootNode.getLeftChild();        }        return rootNode;    }    private class ReturnObject {        private T item;        private ReturnObject(T entry) {            item = entry;        }        public T get() {            return item;        }        public void set(T entry) {            item = entry;        }    }}