package no.uib.info233.tree;import java.util.EmptyStackException;import java.util.Iterator;import java.util.NoSuchElementException;import no.uib.info233.queue.LinkedQueue;import no.uib.info233.queue.Queue;import no.uib.info233.stack.LinkedStack;import no.uib.info233.stack.Stack;/** * A class that implements the ADT binary tree (clonable version). (Project 10 * in Chapter 24.) *  * @author Frank M. Carrano * @author Timothy M. Henry * @version 4.2 */public class LinkedCloneableBinaryTree<T> implements BinaryTree<T>, Cloneable {    private CloneableBinaryTreeNode<T> root;    public LinkedCloneableBinaryTree() {        root = null;    }    public LinkedCloneableBinaryTree(T rootData) {        root = new CloneableBinaryTreeNode<>(rootData);    }    public LinkedCloneableBinaryTree(T rootData, LinkedCloneableBinaryTree<T> leftTree, LinkedCloneableBinaryTree<T> rightTree) {        privateSetTree(rootData, leftTree, rightTree);    }    @Override    public void setTree(T rootData) {        root = new CloneableBinaryTreeNode<>(rootData);    }    @Override    public void setTree(T rootData, BinaryTree<T> leftTree, BinaryTree<T> rightTree) {        privateSetTree(rootData, (LinkedCloneableBinaryTree<T>) leftTree, (LinkedCloneableBinaryTree<T>) rightTree);    }    private void privateSetTree(T rootData, LinkedCloneableBinaryTree<T> leftTree, LinkedCloneableBinaryTree<T> rightTree) {        root = new CloneableBinaryTreeNode<>(rootData);        if ((leftTree != null) && !leftTree.isEmpty()) {            root.setLeftChild(leftTree.root);        }        if ((rightTree != null) && !rightTree.isEmpty()) {            if (rightTree != leftTree) {                root.setRightChild(rightTree.root);            } else {                root.setRightChild((CloneableBinaryTreeNode<T>) (rightTree.root.clone()));            }        }        if ((leftTree != null) && (leftTree != this)) {            leftTree.clear();        }        if ((rightTree != null) && (rightTree != this)) {            rightTree.clear();        }    }    @Override    public T getRootData() {        T rootData = null;        if (root != null) {            rootData = root.getData();        }        return rootData;    }    @Override    public Boolean isEmpty() {        return root == null;    }    @Override    public void clear() {        root = null;    }//	protected void setRootData(T rootData)    public void setRootData(T rootData) {        root.setData(rootData);    }    protected void setRootNode(CloneableBinaryTreeNode<T> rootNode) {        root = rootNode;    }    protected CloneableBinaryTreeNode<T> getRootNode() {        return root;    }    @Override    public Integer getHeight() {        return root.getHeight();    }    @Override    public Integer getNumberOfNodes() {        return root.getNumberOfNodes();    }    /**     * Makes a clone of this tree.     *      * @return The clone of this tree.     */    @Override    public Object clone() {        LinkedCloneableBinaryTree<T> theCopy = new LinkedCloneableBinaryTree<>();        @SuppressWarnings("unchecked")        CloneableBinaryTreeNode<T> temp = (CloneableBinaryTreeNode<T>) root.clone();        theCopy.root = temp;        return theCopy;    }    @Override    public Iterator<T> preorderIterator() {        return new PreorderIterator();    }    @Override    public Iterator<T> inorderIterator() {        return new InorderIterator();    }    @Override    public Iterator<T> postorderIterator() {        return new PostorderIterator();    }    @Override    public Iterator<T> levelorderIterator() {        return new LevelOrderIterator();    }    private class PreorderIterator implements Iterator<T> {        private Stack<CloneableBinaryTreeNode<T>> nodeStack;        public PreorderIterator() {            nodeStack = new LinkedStack<>();            if (root != null) {                nodeStack.push(root);            }        }        @Override        public boolean hasNext() {            return !nodeStack.isEmpty();        }        @Override        public T next() {            CloneableBinaryTreeNode<T> nextNode;            if (hasNext()) {                nextNode = nodeStack.pop();                CloneableBinaryTreeNode<T> leftChild = nextNode.getLeftChild();                CloneableBinaryTreeNode<T> rightChild = nextNode.getRightChild();                // Push into stack in reverse order of recursive calls                if (rightChild != null) {                    nodeStack.push(rightChild);                }                if (leftChild != null) {                    nodeStack.push(leftChild);                }            } else {                throw new NoSuchElementException();            }            return nextNode.getData();        }        @Override        public void remove() {            throw new UnsupportedOperationException();        }    }    public void iterativePreorderTraverse() {        Stack<CloneableBinaryTreeNode<T>> nodeStack = new LinkedStack<>();        if (root != null) {            nodeStack.push(root);        }        CloneableBinaryTreeNode<T> nextNode;        while (!nodeStack.isEmpty()) {            nextNode = nodeStack.pop();            CloneableBinaryTreeNode<T> leftChild = nextNode.getLeftChild();            CloneableBinaryTreeNode<T> rightChild = nextNode.getRightChild();            // Push into stack in reverse order of recursive calls            if (rightChild != null) {                nodeStack.push(rightChild);            }            if (leftChild != null) {                nodeStack.push(leftChild);            }            System.out.println(nextNode.getData());        }    }    private class InorderIterator implements Iterator<T> {        private Stack<CloneableBinaryTreeNode<T>> nodeStack;        private CloneableBinaryTreeNode<T> currentNode;        public InorderIterator() {            nodeStack = new LinkedStack<>();            currentNode = root;        }        @Override        public boolean hasNext() {            return !nodeStack.isEmpty() || (currentNode != null);        }        @Override        public T next() {            CloneableBinaryTreeNode<T> nextNode = null;            // Find leftmost node with no left child            while (currentNode != null) {                nodeStack.push(currentNode);                currentNode = currentNode.getLeftChild();            }            // Get leftmost node, then move to its right subtree            if (!nodeStack.isEmpty()) {                nextNode = nodeStack.pop();                assert nextNode != null; // Since nodeStack was not empty                                         // before the pop                currentNode = nextNode.getRightChild();            } else {                throw new NoSuchElementException();            }            return nextNode.getData();        }        @Override        public void remove() {            throw new UnsupportedOperationException();        }    }    public void iterativeInorderTraverse() {        Stack<CloneableBinaryTreeNode<T>> nodeStack = new LinkedStack<>();        CloneableBinaryTreeNode<T> currentNode = root;        while (!nodeStack.isEmpty() || (currentNode != null)) {            // Find leftmost node with no left child            while (currentNode != null) {                nodeStack.push(currentNode);                currentNode = currentNode.getLeftChild();            }            // Visit leftmost node, then traverse its right subtree            if (!nodeStack.isEmpty()) {                CloneableBinaryTreeNode<T> nextNode = nodeStack.pop();                assert nextNode != null; // Since nodeStack was not empty                                         // before the pop                System.out.println(nextNode.getData());                currentNode = nextNode.getRightChild();            }        }    }    private class PostorderIterator implements Iterator<T> {        private Stack<CloneableBinaryTreeNode<T>> nodeStack;        private CloneableBinaryTreeNode<T> currentNode;        public PostorderIterator() {            nodeStack = new LinkedStack<>();            currentNode = root;        }        @Override        public boolean hasNext() {            return !nodeStack.isEmpty() || (currentNode != null);        }        @Override        public T next() {            CloneableBinaryTreeNode<T> leftChild, rightChild, nextNode = null;            // Find leftmost leaf            while (currentNode != null) {                nodeStack.push(currentNode);                leftChild = currentNode.getLeftChild();                if (leftChild == null) {                    currentNode = currentNode.getRightChild();                } else {                    currentNode = leftChild;                }            }            // Stack is not empty either because we just pushed a node, or            // it wasn't empty to begin with since hasNext() is true.            // But Iterator specifies an exception for next() in case            // hasNext() is false.            if (!nodeStack.isEmpty()) {                nextNode = nodeStack.pop();                // nextNode != null since stack was not empty before pop                CloneableBinaryTreeNode<T> parent = null;                try {                    parent = nodeStack.peek();                    if (nextNode == parent.getLeftChild()) {                        currentNode = parent.getRightChild();                    } else {                        currentNode = null;                    }                } catch (EmptyStackException e) {                    currentNode = null;                }            } else {                throw new NoSuchElementException();            }            return nextNode.getData();        }        @Override        public void remove() {            throw new UnsupportedOperationException();        }    }    private class LevelOrderIterator implements Iterator<T> {        private Queue<CloneableBinaryTreeNode<T>> nodeQueue;        public LevelOrderIterator() {            nodeQueue = new LinkedQueue<>();            if (root != null) {                nodeQueue.enqueue(root);            }        }        @Override        public boolean hasNext() {            return !nodeQueue.isEmpty();        }        @Override        public T next() {            CloneableBinaryTreeNode<T> nextNode;            if (hasNext()) {                nextNode = nodeQueue.dequeue();                CloneableBinaryTreeNode<T> leftChild = nextNode.getLeftChild();                CloneableBinaryTreeNode<T> rightChild = nextNode.getRightChild();                // Add to queue in order of recursive calls                if (leftChild != null) {                    nodeQueue.enqueue(leftChild);                }                if (rightChild != null) {                    nodeQueue.enqueue(rightChild);                }            } else {                throw new NoSuchElementException();            }            return nextNode.getData();        }        @Override        public void remove() {            throw new UnsupportedOperationException();        }    }}