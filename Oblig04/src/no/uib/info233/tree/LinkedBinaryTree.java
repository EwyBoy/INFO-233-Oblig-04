package no.uib.info233.tree;import java.util.Iterator;import java.util.NoSuchElementException;import no.uib.info233.queue.LinkedQueue;import no.uib.info233.queue.Queue;import no.uib.info233.stack.LinkedStack;import no.uib.info233.stack.Stack;/** * A class that implements the ADT binary tree. *  * @author Frank M. Carrano * @author Timothy M. Henry * @version 4.2 */public class LinkedBinaryTree<T> implements BinaryTree<T> {    private BinaryTreeNode<T> root;    public LinkedBinaryTree() {        root = null;    }    public LinkedBinaryTree(T rootData) {        root = new BinaryTreeNode<>(rootData);    }    public LinkedBinaryTree(T rootData, LinkedBinaryTree<T> leftTree, LinkedBinaryTree<T> rightTree) {        privateSetTree(rootData, leftTree, rightTree);    }    @Override    public void setTree(T rootData) {        root = new BinaryTreeNode<>(rootData);    }    @Override    public void setTree(T rootData, BinaryTree<T> leftTree, BinaryTree<T> rightTree) {        privateSetTree(rootData, (LinkedBinaryTree<T>) leftTree, (LinkedBinaryTree<T>) rightTree);    }    private void privateSetTree(T rootData, LinkedBinaryTree<T> leftTree, LinkedBinaryTree<T> rightTree) {        root = new BinaryTreeNode<>(rootData);        if ((leftTree != null) && !leftTree.isEmpty()) {            root.setLeftChild(leftTree.root);        }        if ((rightTree != null) && !rightTree.isEmpty()) {            if (rightTree != leftTree) {                root.setRightChild(rightTree.root);            } else {                root.setRightChild(rightTree.root.copy());            }        }        if ((leftTree != null) && (leftTree != this)) {            leftTree.clear();        }        if ((rightTree != null) && (rightTree != this)) {            rightTree.clear();        }    }    @Override    public T getRootData() {        if (isEmpty()) {            throw new EmptyTreeException();        } else {            return root.getData();        }    }    @Override    public Boolean isEmpty() {        return root == null;    }    @Override    public void clear() {        root = null;    }    protected void setRootData(T rootData) {        root.setData(rootData);    }    protected void setRootNode(BinaryTreeNode<T> rootNode) {        root = rootNode;    }    protected BinaryTreeNode<T> getRootNode() {        return root;    }    @Override    public Integer getHeight() {        return root.getHeight();    }    @Override    public Integer getNumberOfNodes() {        return root.getNumberOfNodes();    }    @Override    public Iterator<T> preorderIterator() {        return new PreorderIterator();    }    @Override    public Iterator<T> inorderIterator() {        return new InorderIterator();    }    @Override    public Iterator<T> postorderIterator() {        return new PostorderIterator();    }    @Override    public Iterator<T> levelorderIterator() {        return new LevelOrderIterator();    }    private class PreorderIterator implements Iterator<T> {        private Stack<BinaryTreeNode<T>> nodeStack;        public PreorderIterator() {            nodeStack = new LinkedStack<>();            if (root != null) {                nodeStack.push(root);            }        }        @Override        public boolean hasNext() {            return !nodeStack.isEmpty();        }        @Override        public T next() {            BinaryTreeNode<T> nextNode;            if (hasNext()) {                nextNode = nodeStack.pop();                BinaryTreeNode<T> leftChild = nextNode.getLeftChild();                BinaryTreeNode<T> rightChild = nextNode.getRightChild();                // Push into stack in reverse order of recursive calls                if (rightChild != null) {                    nodeStack.push(rightChild);                }                if (leftChild != null) {                    nodeStack.push(leftChild);                }            } else {                throw new NoSuchElementException();            }            return nextNode.getData();        }        @Override        public void remove() {            throw new UnsupportedOperationException();        }    }    public void iterativePreorderTraverse() {        Stack<BinaryTreeNode<T>> nodeStack = new LinkedStack<>();        if (root != null) {            nodeStack.push(root);        }        BinaryTreeNode<T> nextNode;        while (!nodeStack.isEmpty()) {            nextNode = nodeStack.pop();            BinaryTreeNode<T> leftChild = nextNode.getLeftChild();            BinaryTreeNode<T> rightChild = nextNode.getRightChild();            // Push into stack in reverse order of recursive calls            if (rightChild != null) {                nodeStack.push(rightChild);            }            if (leftChild != null) {                nodeStack.push(leftChild);            }            System.out.print(nextNode.getData() + " ");        }    }    private class InorderIterator implements Iterator<T> {        private Stack<BinaryTreeNode<T>> nodeStack;        private BinaryTreeNode<T> currentNode;        public InorderIterator() {            nodeStack = new LinkedStack<>();            currentNode = root;        }        @Override        public boolean hasNext() {            return !nodeStack.isEmpty() || (currentNode != null);        }        @Override        public T next() {            BinaryTreeNode<T> nextNode = null;            // Find leftmost node with no left child            while (currentNode != null) {                nodeStack.push(currentNode);                currentNode = currentNode.getLeftChild();            }            // Get leftmost node, then move to its right subtree            if (!nodeStack.isEmpty()) {                nextNode = nodeStack.pop();                assert nextNode != null; // Since nodeStack was not empty                                         // before the pop                currentNode = nextNode.getRightChild();            } else {                throw new NoSuchElementException();            }            return nextNode.getData();        }        @Override        public void remove() {            throw new UnsupportedOperationException();        }    }    public void iterativeInorderTraverse() {        Stack<BinaryTreeNode<T>> nodeStack = new LinkedStack<>();        BinaryTreeNode<T> currentNode = root;        while (!nodeStack.isEmpty() || (currentNode != null)) {            // Find leftmost node with no left child            while (currentNode != null) {                nodeStack.push(currentNode);                currentNode = currentNode.getLeftChild();            }            // Visit leftmost node, then traverse its right subtree            if (!nodeStack.isEmpty()) {                BinaryTreeNode<T> nextNode = nodeStack.pop();                assert nextNode != null; // Since nodeStack was not empty                                         // before the pop                System.out.print(nextNode.getData() + " ");                currentNode = nextNode.getRightChild();            }        }    }    private class PostorderIterator implements Iterator<T> {        private Stack<BinaryTreeNode<T>> nodeStack;        private BinaryTreeNode<T> currentNode;        public PostorderIterator() {            nodeStack = new LinkedStack<>();            currentNode = root;        }        @Override        public boolean hasNext() {            return !nodeStack.isEmpty() || (currentNode != null);        }        @Override        public T next() {            BinaryTreeNode<T> leftChild, rightChild, nextNode = null;            // Find leftmost leaf            while (currentNode != null) {                nodeStack.push(currentNode);                leftChild = currentNode.getLeftChild();                if (leftChild == null) {                    currentNode = currentNode.getRightChild();                } else {                    currentNode = leftChild;                }            }            // Stack is not empty either because we just pushed a node, or            // it wasn't empty to begin with since hasNext() is true.            // But Iterator specifies an exception for next() in case            // hasNext() is false.            if (!nodeStack.isEmpty()) {                nextNode = nodeStack.pop();                // nextNode != null since stack was not empty before pop                BinaryTreeNode<T> parent = null;                if (!nodeStack.isEmpty()) {                    parent = nodeStack.peek();                    if (nextNode == parent.getLeftChild()) {                        currentNode = parent.getRightChild();                    } else {                        currentNode = null;                    }                } else {                    currentNode = null;                }            } else {                throw new NoSuchElementException();            }            return nextNode.getData();        }        /*         * public T next() { BinaryNode<T> leftChild, rightChild, nextNode = null;         *          * // Find leftmost leaf while (currentNode != null) {         * nodeStack.push(currentNode); leftChild = currentNode.getLeftChild(); if         * (leftChild == null) currentNode = currentNode.getRightChild(); else         * currentNode = leftChild; }         *          * // Stack is not empty either because we just pushed a node, or // it wasn't         * empty to begin with since hasNext() is true. // But Iterator specifies an         * exception for next() in case // hasNext() is false.         *          * if (!nodeStack.isEmpty()) { nextNode = nodeStack.pop(); // nextNode != null         * since stack was not empty before pop         *          * BinaryNode<T> parent = null; try { parent = nodeStack.peek(); if (nextNode ==         * parent.getLeftChild()) currentNode = parent.getRightChild(); else currentNode         * = null; } catch(EmptyStackException e) { currentNode = null; } } else { throw         * new NoSuchElementException(); }         *          * return nextNode.getData(); }         */        @Override        public void remove() {            throw new UnsupportedOperationException();        }    }    private class LevelOrderIterator implements Iterator<T> {        private Queue<BinaryTreeNode<T>> nodeQueue;        public LevelOrderIterator() {            nodeQueue = new LinkedQueue<>();            if (root != null) {                nodeQueue.enqueue(root);            }        }        @Override        public boolean hasNext() {            return !nodeQueue.isEmpty();        }        @Override        public T next() {            BinaryTreeNode<T> nextNode;            if (hasNext()) {                nextNode = nodeQueue.dequeue();                BinaryTreeNode<T> leftChild = nextNode.getLeftChild();                BinaryTreeNode<T> rightChild = nextNode.getRightChild();                // Add to queue in order of recursive calls                if (leftChild != null) {                    nodeQueue.enqueue(leftChild);                }                if (rightChild != null) {                    nodeQueue.enqueue(rightChild);                }            } else {                throw new NoSuchElementException();            }            return nextNode.getData();        }        @Override        public void remove() {            throw new UnsupportedOperationException();        }    }}