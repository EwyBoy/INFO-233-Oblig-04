package no.uib.info233.heap;import java.util.Arrays;/** * A class that implements the ADT maxheap by using an array. * * @author Frank M. Carrano * @author Timothy M. Henry * @author Joseph Erickson * @version 4.2 */public class ArrayMaxHeap<T extends Comparable<? super T>> implements MaxHeap<T> {    private T[] heap; // Array of heap entries    private int lastIndex; // Index of last entry and number of entries    private boolean initialized = false;    private static final Integer DEFAULT_CAPACITY = 25;    private static final Integer MAX_CAPACITY = 10000;    public ArrayMaxHeap() {        this(DEFAULT_CAPACITY); // Call next constructor    }    public ArrayMaxHeap(Integer initialCapacity) {        checkCapacity(initialCapacity);        // The cast is safe because the new array contains null entries        @SuppressWarnings("unchecked")        T[] tempHeap = (T[]) new Comparable[initialCapacity + 1];        heap = tempHeap;        lastIndex = 0;        initialized = true;    }    public ArrayMaxHeap(T[] entries) {        checkCapacity(entries.length);        // The cast is safe because the new array contains null entries        @SuppressWarnings("unchecked")        T[] tempHeap = (T[]) new Comparable[entries.length + 1];        heap = tempHeap;        lastIndex = entries.length;        // Copy given array to data field        for (int index = 0; index < entries.length; index++) {            heap[index + 1] = entries[index];        }        // Create heap        for (int rootIndex = lastIndex / 2; rootIndex > 0; rootIndex--) {            reheap(rootIndex);        }        initialized = true;    }    @Override    public void add(T entry) {        checkInitialization();        lastIndex++;        ensureCapacity();        int newIndex = lastIndex;        int parentIndex = newIndex / 2;        while ((parentIndex > 0) && entry.compareTo(heap[parentIndex]) > 0) {            heap[newIndex] = heap[parentIndex];            newIndex = parentIndex;            parentIndex = newIndex / 2;        }        heap[newIndex] = entry;    }    @Override    public T removeMax() {        checkInitialization();        T root = null;        if (!isEmpty()) {            root = heap[1]; // Return value            heap[1] = heap[lastIndex]; // Form a semiheap            lastIndex--; // Decrease size            reheap(1); // Transform to a heap        }        return root;    }    @Override    public T getMax() {        checkInitialization();        T root = null;        if (!isEmpty()) {            root = heap[1];        }        return root;    }    @Override    public Boolean isEmpty() {        return lastIndex < 1;    }    @Override    public Integer getSize() {        return lastIndex;    }    @Override    public void clear() {        checkInitialization();        while (lastIndex > -1) {            heap[lastIndex] = null;            lastIndex--;        }        lastIndex = 0;    }    // Precondition: checkInitialization has been called.    private void reheap(int rootIndex) {        boolean done = false;        T orphan = heap[rootIndex];        int leftChildIndex = 2 * rootIndex;        while (!done && (leftChildIndex <= lastIndex)) {            int largerChildIndex = leftChildIndex; // Assume larger            int rightChildIndex = leftChildIndex + 1;            if ((rightChildIndex <= lastIndex) && heap[rightChildIndex].compareTo(heap[largerChildIndex]) > 0) {                largerChildIndex = rightChildIndex;            }            if (orphan.compareTo(heap[largerChildIndex]) < 0) {                heap[rootIndex] = heap[largerChildIndex];                rootIndex = largerChildIndex;                leftChildIndex = 2 * rootIndex;            } else {                done = true;            }        }        heap[rootIndex] = orphan;    }    // Doubles the capacity of the array heap if it is full.    // Precondition: checkInitialization has been called.    private void ensureCapacity() {        if (lastIndex >= heap.length) {            int newCapacity = 2 * heap.length;            checkCapacity(newCapacity);            heap = Arrays.copyOf(heap, newCapacity);        }    }    // Throws an exception if this object is not initialized.    private void checkInitialization() {        if (!initialized) {            throw new SecurityException("MaxHeap object is not initialized properly.");        }    }    // Ensures that the client requests a capacity    // that is not too small or too large.    private void checkCapacity(int capacity) {        if (capacity < DEFAULT_CAPACITY) {            capacity = DEFAULT_CAPACITY;        } else if (capacity > MAX_CAPACITY) {            throw new IllegalStateException(                    "Attempt to create a heap " + "whose capacity is larger than " + MAX_CAPACITY);        }    }}